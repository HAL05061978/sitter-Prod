[33m8477e35[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmaster[m[33m)[m Scheduling Open Period
[33m9b26c5b[m Scheduing Open period request debug
[33me73dbad[m Debugging Scheduling
[33mf755ec2[m Scheduling in progress 1
[33mfd6337a[m Scheduling started
[33m3e08a9d[m Update with new member messaging
[33m6252a06[m New DB test - working on  messaging
[33m3da4ae7[m Groups functionality with RLS disabled
[33mf6322c7[m Fixed Group filters
[33me6e2908[m Fixed Group Invitation bug/loop
[33m0646ec2[m Open blocks cont debug
[1mdiff --git a/app/schedule/page.tsx b/app/schedule/page.tsx[m
[1mindex d9d42be..e65f11f 100644[m
[1m--- a/app/schedule/page.tsx[m
[1m+++ b/app/schedule/page.tsx[m
[36m@@ -218,6 +218,7 @@[m [mexport default function SchedulePage() {[m
   const [invitationProposals, setInvitationProposals] = useState<any[]>([]);[m
   const [showProposalsModal, setShowProposalsModal] = useState(false);[m
   const [selectedInvitationForProposals, setSelectedInvitationForProposals] = useState<GroupInvitation | null>(null);[m
[32m+[m[32m  const [originalRequestId, setOriginalRequestId] = useState<string>('');[m
   [m
   // Form states[m
   const [requestForm, setRequestForm] = useState({[m
[36m@@ -601,32 +602,114 @@[m [mexport default function SchedulePage() {[m
       .in("group_id", groupIds)[m
       .order("created_at", { ascending: false });[m
 [m
[31m-    // Filter out completed reciprocal requests (accepted/rejected) since they're already handled[m
[32m+[m[32m    // Fetch responses for all requests to determine what to show[m
[32m+[m[32m    const { data: allResponsesData } = await supabase[m
[32m+[m[32m      .from("care_responses")[m
[32m+[m[32m      .select("*")[m
[32m+[m[32m      .in("request_id", (allRequestsData || []).map(r => r.id))[m
[32m+[m[32m      .order("created_at", { ascending: false });[m
[32m+[m
[32m+[m[32m    console.log('All requests before filtering:', allRequestsData?.length || 0);[m
[32m+[m[32m    console.log('Open block requests before filtering:', (allRequestsData || []).filter(r => r.request_type === 'open_block').length);[m
[32m+[m[41m    [m
[32m+[m[32m    // Comprehensive filtering logic[m
     const filteredRequests = (allRequestsData || []).filter(request => {[m
[31m-      // Keep all non-reciprocal requests[m
[31m-      if (request.request_type !== 'reciprocal') {[m
[32m+[m[32m      // Open block requests: Show to all eligible parents (not just the parent of the child being cared for)[m
[32m+[m[32m      if (request.request_type === 'open_block') {[m
[32m+[m[32m        // Don't show open_block requests that the current user has already responded to[m
[32m+[m[32m        const userResponses = (allResponsesData || []).filter(response =>[m[41m [m
[32m+[m[32m          response.responder_id === userId && response.request_id === request.id[m
[32m+[m[32m        );[m
[32m+[m[32m        if (userResponses.length > 0) {[m
[32m+[m[32m          return false; // User has already responded to this open_block request[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Don't show open_block requests that have been accepted by someone else[m
[32m+[m[32m        const acceptedResponses = (allResponsesData || []).filter(response =>[m[41m [m
[32m+[m[32m          response.request_id === request.id && response.status === 'accepted'[m
[32m+[m[32m        );[m
[32m+[m[32m        if (acceptedResponses.length > 0) {[m
[32m+[m[32m          return false; // This open_block request has been accepted by someone[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Don't show open_block requests to the person who created them (Parent B)[m
[32m+[m[32m        if (request.open_block_parent_id === userId) {[m
[32m+[m[32m          return false; // Parent B shouldn't see their own open block requests[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Show to all other eligible parents in the group[m
         return true;[m
       }[m
[31m-      // For reciprocal requests, only keep if they're not completed (not accepted/rejected)[m
[31m-      return request.status !== 'accepted' && request.status !== 'rejected';[m
[32m+[m[41m      [m
[32m+[m[32m      // For reciprocal requests, only keep if they're not completed[m
[32m+[m[32m      if (request.request_type === 'reciprocal') {[m
[32m+[m[32m        return request.status !== 'accepted' && request.status !== 'rejected';[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      // Keep all other request types[m
[32m+[m[32m      return true;[m
     });[m
 [m
[31m-    setRequests(filteredRequests);[m
[31m-[m
[31m-    // Fetch responses for these requests (including all statuses)[m
[31m-    if (filteredRequests && filteredRequests.length > 0) {[m
[31m-      const requestIds = filteredRequests.map((r: CareRequest) => r.id);[m
[31m-      const { data: responsesData } = await supabase[m
[31m-        .from("care_responses") // Updated table name[m
[31m-        .select("*")[m
[31m-        .in("request_id", requestIds)[m
[31m-        .order("created_at", { ascending: false });[m
 [m
[31m-[m
[31m-[m
[31m-      setResponses(responsesData || []);[m
[31m-    } else {[m
[31m-      setResponses([]);[m
[32m+[m[41m    [m
[32m+[m[32m    setRequests(filteredRequests);[m
[32m+[m[32m    setResponses(allResponsesData || []);[m
[32m+[m[41m    [m
[32m+[m[32m    // For open block requests that were filtered out due to missing child data,[m
[32m+[m[32m    // fetch the child data and update the requests[m
[32m+[m[32m    const openBlockRequests = (allRequestsData || []).filter(request =>[m[41m [m
[32m+[m[32m      request.request_type === 'open_block' &&[m[41m [m
[32m+[m[32m      !allGroupChildren.find(child => child.id === request.child_id)[m
[32m+[m[32m    );[m
[32m+[m[41m    [m
[32m+[m[32m    if (openBlockRequests.length > 0) {[m
[32m+[m[32m      const missingChildIds = openBlockRequests.map(request => request.child_id);[m
[32m+[m[32m      const { data: missingChildren } = await supabase[m
[32m+[m[32m        .from('children')[m
[32m+[m[32m        .select('id, parent_id')[m
[32m+[m[32m        .in('id', missingChildIds);[m
[32m+[m[41m      [m
[32m+[m[32m      if (missingChildren) {[m
[32m+[m[32m        // Add missing children to allGroupChildren[m
[32m+[m[32m        const updatedAllGroupChildren = [...allGroupChildren, ...missingChildren];[m
[32m+[m[41m        [m
[32m+[m[32m        // Re-filter the requests with complete child data[m
[32m+[m[32m        const finalFilteredRequests = (allRequestsData || []).filter(request => {[m
[32m+[m[32m          if (request.request_type === 'open_block') {[m
[32m+[m[32m            // Use the same logic as the main filtering above[m
[32m+[m[32m            // Don't show open_block requests that the current user has already responded to[m
[32m+[m[32m            const userResponses = (allResponsesData || []).filter(response =>[m[41m [m
[32m+[m[32m              response.responder_id === userId && response.request_id === request.id[m
[32m+[m[32m            );[m
[32m+[m[32m            if (userResponses.length > 0) {[m
[32m+[m[32m              return false;[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            // Don't show open_block requests that have been accepted by someone else[m
[32m+[m[32m            const acceptedResponses = (allResponsesData || []).filter(response =>[m[41m [m
[32m+[m[32m              response.request_id === request.id && response.status === 'accepted'[m
[32m+[m[32m            );[m
[32m+[m[32m            if (acceptedResponses.length > 0) {[m
[32m+[m[32m              return false;[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            // Don't show open_block requests to the person who created them (Parent B)[m
[32m+[m[32m            if (request.open_block_parent_id === userId) {[m
[32m+[m[32m              return false;[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m            return true;[m
[32m+[m[32m          }[m
[32m+[m[41m          [m
[32m+[m[32m          if (request.request_type === 'reciprocal') {[m
[32m+[m[32m            return request.status !== 'accepted' && request.status !== 'rejected';[m
[32m+[m[32m          }[m
[32m+[m[41m          [m
[32m+[m[32m          retur